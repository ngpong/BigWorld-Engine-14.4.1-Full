//-----------------------------------------------------//
//                                                     //
//            Code generated by RT/shader              //
//            at: 10/05/2005 1:46:09 PM                //
//                                                     //
//-----------------------------------------------------//
#include "rtshader_include.fxh"

// Structures
struct Technique1_Pass1_VS_OUT 
{
	float4 position : POSITION;
	float2 uv0 : TEXCOORD0;
	float4 diffuseColor : COLOR0;
	float4 specularColor : COLOR1;
	float falloff : TEXCOORD1;
};

struct Technique1_Pass1_PS_OUT 
{
	float4 color : COLOR0;
};

// Uniform Parameters
float4x4 projTM : WorldViewProjection;
float4 world[51] : WorldPalette;
float4x4 viewProjection : ViewProjection;
float4 eyePos : WorldEyePosition;
float4 Color
<
	string UIType = "MaxSwatch";
	string UIWidget = "Color";
	string UIName = "Colour";
	bool artistEditable = true; 
	 
> = {0.9, 0.6, 1, 1.0};
float Ambient_Amount
<
	string UIType = "MaxSpinner";
	string UIName = "Ambient Amount";
	bool artistEditable = true; 
> = 0.4;

float3 transformPos( float4 pos, int index )
{
	float3 ret = {	dot( world[index], pos ),
					dot( world[index + 1], pos ),
					dot( world[index + 2], pos ) };
	return ret;
}

float4 transformPos( float4 pos, float weights[3], int indices[3] )
{
	float4 ret = float4( 0, 0, 0, 1 );
	ret.xyz = transformPos( pos, indices[0] ) * weights[0];
	ret.xyz += transformPos( pos, indices[1] ) * weights[1];
	ret.xyz += transformPos( pos, indices[2] ) * weights[2];
	return ret;
}

float3 transformNormaliseVector( float3 v, int index )
{
	float3 ret;
	ret.x = dot( world[index + 0].xyz, v  );
	ret.y = dot( world[index + 1].xyz, v );
	ret.z = dot( world[index + 2].xyz, v );
	return normalize( ret );
}

Technique1_Pass1_VS_OUT Technique1_Pass1_VS(
		float3 pos : POSITION,
		float2 uv0 : TEXCOORD0,
		float3 norm : NORMAL,
		float3 inindices:	BLENDINDICES,
		float2 inweights:	BLENDWEIGHT )
{


	Technique1_Pass1_VS_OUT OUT;
	int indices[3] = { inindices.x * 255.5,
							inindices.y * 255.5,
							inindices.z * 255.5 };
							
	float weights[3] = { inweights.x, inweights.y, 1 - inweights.y - inweights.x };
	
	float4 worldPos = transformPos( float4(pos,1), weights, indices );

	OUT.position = mul(worldPos, viewProjection);
	OUT.uv0 = uv0;
	float4 surfPos1 = worldPos;
	float3 surfNorm1 = transformNormaliseVector( norm, indices[0] );
	//float2x3 difSpec1 = LightArray(lightArray, 4, surfPos1, surfNorm1, eyePos, 8);
	float2x3 difSpec1 = LightArray(surfPos1, surfNorm1, eyePos, 8);
	OUT.diffuseColor = float4(difSpec1[0], 1);
	OUT.specularColor = float4(difSpec1[1], 1);
	float val1 = max(0, dot(surfNorm1, normalize(eyePos.xyz-surfPos1)));
	float a1 = 1-val1;
	OUT.falloff = a1*a1;
	return OUT;
}

Technique1_Pass1_PS_OUT Technique1_Pass1_PS(
		float4 diffuse : COLOR0,
		float4 specular : COLOR1,
		float falloff : TEXCOORD1,
		uniform float4 Color,
		uniform float Ambient_Amount)
{
	Technique1_Pass1_PS_OUT OUT;
	float4 b1 = pow(specular, 1);
	float4 a1 = diffuse+b1;
	float4 u1 = a1*2;
	float4 a2 = floor(u1);
	float4 b2 = a2/2;
	float4 b3 = Ambient_Amount+b2;
	float4 a3 = Color*b3;
	float base1 = 1-falloff;
	float a4 = pow(base1, 0.5);
	float a5 = a4-0.5;
	float a6 = a5*1;
	float u2 = a6+0.5;
	float b4 = saturate(u2);
	OUT.color = a3*b4;
	return OUT;
}

// Techniques
technique Technique1
<
	bool skinned = true;
>
{
	pass Pass1
	{
		VertexShader = compile vs_2_0 Technique1_Pass1_VS();
		PixelShader = compile ps_2_0 Technique1_Pass1_PS(Color, Ambient_Amount);
		ZEnable = true;
		ZWriteEnable = true;
		ZFunc = LessEqual;
		CullMode = CCW;
		AlphaBlendEnable = false;
		FogEnable = false;
	}
}

