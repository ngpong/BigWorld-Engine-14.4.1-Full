//-----------------------------------------------------//
//                                                     //
//            Code generated by RT/shader              //
//            at: 10/05/2005 1:44:00 PM                //
//                                                     //
//-----------------------------------------------------//


// Structures
struct Technique1_Pass1_VS_OUT 
{
	float4 position : POSITION;
	float2 uv0 : TEXCOORD0;
	float falloff1 : TEXCOORD1;
	float3 reflectVector : TEXCOORD2;
	float3 refractVector0 : TEXCOORD3;
	float3 refractVector1 : TEXCOORD4;
	float3 refractVector2 : TEXCOORD5;
};

struct Technique1_Pass1_PS_OUT 
{
	float4 color : COLOR0;
};


// Uniform Parameters
float4x4 projTM : WorldViewProjection;
float4x4 worldTM : World;
float4 eyePos : WorldEyePosition;
float4x4 worldITTM : WorldIT;
float4 world[51] : WorldPalette;
float4x4 viewProjection : ViewProjection;
float Red_Refr_Index
<
	string UIType = "MaxSpinner";
	string UIName = "Red Refr Index";
	bool artistEditable = true;

> = 1.2;
float Green_Refr_Index
<
	string UIType = "MaxSpinner";
	string UIName = "Green Refr Index";
	bool artistEditable = true;

> = 1.25;
float Blue_Refr_Index
<
	string UIType = "MaxSpinner";
	string UIName = "Blue Refr Index";
	bool artistEditable = true;

> = 1.3;
texture Refraction
<
	string name = "C:\\Program Files\\RTzen\\RTshaderGinza\\media\\images\\nvlobby_cube_mipmap.dds";
	string type = "CUBE";
	string UIName = "Refraction";
	bool artistEditable = true;
	 
>;
texture Refraction2
<
	string name = "C:\\Program Files\\RTzen\\RTshaderGinza\\media\\images\\nvlobby_cube_mipmap.dds";
	string type = "CUBE";
	string UIName = "Refraction2";
	bool artistEditable = true;
	 
>;
texture Refraction3
<
	string name = "C:\\Program Files\\RTzen\\RTshaderGinza\\media\\images\\nvlobby_cube_mipmap.dds";
	string type = "CUBE";
	string UIName = "Refraction3";
	bool artistEditable = true;
	 
>;
texture Reflection
<
	string name = "C:\\Program Files\\RTzen\\RTshaderGinza\\media\\images\\nvlobby_cube_mipmap.dds";
	string type = "CUBE";
	string UIName = "Reflection";
	bool artistEditable = true;
	 
>;

// Samplers
sampler RefractionSampler = sampler_state
{
	Texture = <Refraction>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = LINEAR;
};

sampler Refraction2Sampler = sampler_state
{
	Texture = <Refraction2>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = LINEAR;
};

sampler Refraction3Sampler = sampler_state
{
	Texture = <Refraction3>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = LINEAR;
};

sampler ReflectionSampler = sampler_state
{
	Texture = <Reflection>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = LINEAR;
};


// Functions
float3 RefractEyeVector(
		float4 surfPos,
		float3 surfNorm,
		float4 eyePos,
		float refIndex)
{
	float3 I = normalize(surfPos.xyz-eyePos.xyz);
	float IdotN = dot(I, surfNorm);
	float k = 1-((refIndex*refIndex)*(1-(IdotN*IdotN)));
	return (refIndex*I)-(((refIndex*IdotN)+sqrt(k))*surfNorm);
}

float Falloff(
		float4 surface,
		float4 eye,
		float3 norm,
		float amount)
{
	float3 eyeVect = normalize(eye.xyz-surface.xyz);
	float falloff = 1-dot(eyeVect, norm);
	return pow(falloff, amount);
}

float3 transformPos( float4 pos, int index )
{
	float3 ret = {	dot( world[index], pos ),
					dot( world[index + 1], pos ),
					dot( world[index + 2], pos ) };
	return ret;
}

float4 transformPos( float4 pos, float weights[3], int indices[3] )
{
	float4 ret = float4( 0, 0, 0, 1 );
	ret.xyz = transformPos( pos, indices[0] ) * weights[0];
	ret.xyz += transformPos( pos, indices[1] ) * weights[1];
	ret.xyz += transformPos( pos, indices[2] ) * weights[2];
	return ret;
}

float3 transformNormaliseVector( float3 v, int index )
{
	float3 ret;
	ret.x = dot( world[index + 0].xyz, v  );
	ret.y = dot( world[index + 1].xyz, v );
	ret.z = dot( world[index + 2].xyz, v );
	return normalize( ret );
}

Technique1_Pass1_VS_OUT Technique1_Pass1_VS(
		float3 pos : POSITION,
		float2 uv0 : TEXCOORD0,
		float3 norm : NORMAL,
		float3 inindices:	BLENDINDICES,
		float2 inweights:	BLENDWEIGHT,
		uniform float4x4 projTM,
		uniform float4x4 worldTM,
		uniform float4 eyePos,
		uniform float4x4 worldITTM,
		uniform float Red_Refr_Index,
		uniform float Green_Refr_Index,
		uniform float Blue_Refr_Index)
{
	Technique1_Pass1_VS_OUT OUT;
	int indices[3] = { inindices.x * 255.5,
							inindices.y * 255.5,
							inindices.z * 255.5 };
							
	float weights[3] = { inweights.x, inweights.y, 1 - inweights.y - inweights.x };
	
	float4 worldPos = transformPos( float4(pos,1), weights, indices );

	OUT.position = mul(worldPos, viewProjection);
	OUT.uv0 = uv0;
	float4 surface1 = worldPos;
	float3 norm1 = transformNormaliseVector( norm, indices[0] );
	OUT.falloff1 = Falloff(surface1, eyePos, norm1, 1);
	OUT.reflectVector = reflect(normalize(surface1-eyePos), norm1).xyz;
	OUT.refractVector0 = RefractEyeVector(surface1, norm1, eyePos, Red_Refr_Index);
	OUT.refractVector1 = RefractEyeVector(surface1, norm1, eyePos, Green_Refr_Index);
	OUT.refractVector2 = RefractEyeVector(surface1, norm1, eyePos, Blue_Refr_Index);
	return OUT;
}

Technique1_Pass1_PS_OUT Technique1_Pass1_PS(
		float3 refractionVector0 : TEXCOORD3,
		float3 refractionVector1 : TEXCOORD4,
		float3 refractionVector2 : TEXCOORD5,
		float3 reflectVector : TEXCOORD2,
		float falloff1 : TEXCOORD1,
		uniform sampler RefractionSampler,
		uniform sampler Refraction2Sampler,
		uniform sampler Refraction3Sampler,
		uniform sampler ReflectionSampler)
{
	Technique1_Pass1_PS_OUT OUT;
	float4 vect1 = tex2D(RefractionSampler, refractionVector0.xyz);
	float xValue1 = vect1.x;
	float4 vect2 = tex2D(Refraction2Sampler, refractionVector1.xyz);
	float yValue1 = vect2.y;
	float4 vect3 = tex2D(Refraction3Sampler, refractionVector2.xyz);
	float zValue1 = vect3.z;
	float4 a1 = float4(xValue1, yValue1, zValue1, 1);
	float4 a2 = tex2D(ReflectionSampler, reflectVector.xyz);
	float4 b1 = a2*falloff1;
	OUT.color = a1+b1;
	return OUT;
}


// Techniques
technique Technique1
<
	bool skinned = true;
>
{
	pass Pass1
	{
		VertexShader = compile vs_2_0 Technique1_Pass1_VS(projTM, worldTM, eyePos, worldITTM, Red_Refr_Index, Green_Refr_Index, Blue_Refr_Index);
		PixelShader = compile ps_2_0 Technique1_Pass1_PS(RefractionSampler, Refraction2Sampler, Refraction3Sampler, ReflectionSampler);
		ZEnable = true;
		ZWriteEnable = true;
		ZFunc = LessEqual;
		CullMode = CCW;
		AlphaBlendEnable = false;
		FogEnable = false;
	}
}

